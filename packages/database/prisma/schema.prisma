// Municipal Transparency Platform - Database Schema
// Fase 1A: Core entities for Chilean municipalities

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ===========================
// Core Configuration Entities
// ===========================

/// Municipality: Entidad municipal
model Municipality {
  id        String   @id @default(cuid())
  name      String
  country   String   @default("Chile")
  region    String
  locale    String   @default("es-CL")
  timezone  String   @default("America/Santiago")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  budgets      Budget[]
  expenditures Expenditure[]
  projects     Project[]
  contracts    Contract[]
  users        User[]

  @@index([region])
  @@map("municipalities")
}

/// FiscalYear: Año fiscal
model FiscalYear {
  id       String    @id @default(cuid())
  year     Int       @unique
  status   String    @default("active")
  lockedAt DateTime?

  // Relations
  budgets      Budget[]
  expenditures Expenditure[]

  @@index([year, status])
  @@map("fiscal_years")
}

// ===========================
// Budget & Expenditure Entities
// ===========================

/// Budget: Presupuesto planificado por categoría
model Budget {
  id             String   @id @default(cuid())
  municipalityId String
  fiscalYearId   String
  department     String
  program        String
  category       String
  subcategory    String
  amountPlanned  Decimal  @db.Decimal(18, 2)
  currency       String   @default("CLP")
  notes          String?  @db.Text
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations
  municipality Municipality @relation(fields: [municipalityId], references: [id], onDelete: Cascade)
  fiscalYear   FiscalYear   @relation(fields: [fiscalYearId], references: [id], onDelete: Cascade)

  @@index([municipalityId, fiscalYearId, category, department])
  @@index([category])
  @@map("budgets")
}

/// Expenditure: Gasto ejecutado
model Expenditure {
  id             String   @id @default(cuid())
  municipalityId String
  fiscalYearId   String
  date           DateTime
  department     String
  program        String
  category       String
  subcategory    String
  concept        String
  amountActual   Decimal  @db.Decimal(18, 2)
  currency       String   @default("CLP")
  supplierId     String?
  procurementRef String?
  location       String?  @db.Text // Almacenado como 'POINT(lon lat)' o JSON
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations
  municipality Municipality @relation(fields: [municipalityId], references: [id], onDelete: Cascade)
  fiscalYear   FiscalYear   @relation(fields: [fiscalYearId], references: [id], onDelete: Cascade)
  supplier     Supplier?    @relation(fields: [supplierId], references: [id], onDelete: SetNull)

  @@index([municipalityId, fiscalYearId, date, category, supplierId])
  @@index([date])
  @@index([category])
  @@index([supplierId])
  @@map("expenditures")
}

// ===========================
// Project Entities
// ===========================

/// Project: Proyecto municipal
model Project {
  id              String    @id @default(cuid())
  municipalityId  String
  title           String
  description     String    @db.Text
  status          String
  startDate       DateTime?
  endDate         DateTime?
  department      String
  category        String
  requestedBudget Decimal?  @db.Decimal(18, 2)
  approvedBudget  Decimal?  @db.Decimal(18, 2)
  fundingSourceId String?
  location        String?   @db.Text // Almacenado como 'POINT(lon lat)' o JSON
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relations
  municipality  Municipality   @relation(fields: [municipalityId], references: [id], onDelete: Cascade)
  fundingSource FundingSource? @relation(fields: [fundingSourceId], references: [id], onDelete: SetNull)

  @@index([municipalityId, status])
  @@index([status])
  @@index([category])
  @@map("projects")
}

/// FundingSource: Fuente de financiamiento
model FundingSource {
  id          String   @id @default(cuid())
  name        String
  type        String
  description String?  @db.Text
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  projects Project[]

  @@map("funding_sources")
}

// ===========================
// Supplier Entity
// ===========================

/// Supplier: Proveedor o contratista
model Supplier {
  id        String   @id @default(cuid())
  name      String
  taxId     String?  @unique
  sector    String?
  locality  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  expenditures Expenditure[]
  contracts    Contract[]

  @@index([name])
  @@index([sector])
  @@map("suppliers")
}

/// Contract: Contrato con proveedor
model Contract {
  id             String    @id @default(cuid())
  municipalityId String
  supplierId     String
  title          String
  description    String    @db.Text
  amount         Decimal   @db.Decimal(18, 2)
  currency       String    @default("CLP")
  startDate      DateTime
  endDate        DateTime?
  status         String
  contractNumber String?   @unique
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  // Relations
  municipality Municipality @relation(fields: [municipalityId], references: [id], onDelete: Cascade)
  supplier     Supplier     @relation(fields: [supplierId], references: [id], onDelete: Cascade)

  @@index([municipalityId, supplierId, status])
  @@index([status])
  @@index([startDate, endDate])
  @@map("contracts")
}

// ===========================
// Data Ingestion Entities
// ===========================

/// Dataset: Conjunto de datos a ingerir
model Dataset {
  id              String    @id @default(cuid())
  name            String
  type            String
  sourceUri       String?
  refreshSchedule String?
  schemaVersion   String?
  lastIngestedAt  DateTime?
  checksum        String?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relations
  ingestionRuns IngestionRun[]

  @@index([type])
  @@map("datasets")
}

/// IngestionRun: Ejecución de ingesta
model IngestionRun {
  id           String    @id @default(cuid())
  datasetId    String
  status       String
  startedAt    DateTime  @default(now())
  finishedAt   DateTime?
  rowsIngested Int       @default(0)
  rowsInvalid  Int       @default(0)
  logUri       String?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  // Relations
  dataset Dataset @relation(fields: [datasetId], references: [id], onDelete: Cascade)

  @@index([datasetId, status])
  @@index([startedAt])
  @@map("ingestion_runs")
}

// ===========================
// API Connectors Entities
// ===========================

/// ConnectorConfig: Configuration for external API connectors
model ConnectorConfig {
  id          String    @id @default(cuid())
  name        String    @unique
  type        String // e.g., 'chilecompra', 'budget-source', 'custom'
  description String?   @db.Text
  baseUrl     String
  apiKey      String? // Encrypted API key
  authType    String    @default("none") // 'none', 'api-key', 'oauth', 'bearer'
  authConfig  Json? // Additional auth configuration
  config      Json? // Additional connector-specific configuration
  headers     Json? // Custom headers
  timeout     Int       @default(30000) // Request timeout in ms
  retryCount  Int       @default(3) // Number of retries
  rateLimit   Int? // Requests per minute
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  logs ConnectorLog[]

  @@index([type, isActive])
  @@index([name])
  @@map("connector_configs")
}

/// ConnectorLog: Request/response logging for API connectors
model ConnectorLog {
  id                String    @id @default(cuid())
  connectorConfigId String
  endpoint          String
  method            String // GET, POST, PUT, DELETE
  requestHeaders    Json?
  requestBody       Json?
  responseStatus    Int?
  responseHeaders   Json?
  responseBody      Json?
  duration          Int? // Duration in milliseconds
  error             String?   @db.Text
  createdAt         DateTime  @default(now())

  // Relations
  connectorConfig ConnectorConfig @relation(fields: [connectorConfigId], references: [id], onDelete: Cascade)

  @@index([connectorConfigId, createdAt])
  @@index([createdAt])
  @@index([responseStatus])
  @@map("connector_logs")
}

// ===========================
// User & Audit Entities
// ===========================

/// User: Usuario del sistema
model User {
  id             String    @id @default(cuid())
  email          String    @unique
  passwordHash   String
  role           String
  municipalityId String?
  lastLoginAt    DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  // Relations
  municipality Municipality? @relation(fields: [municipalityId], references: [id], onDelete: SetNull)

  @@index([email, role])
  @@index([role])
  @@map("users")
}

/// QueryAudit: Auditoría de consultas
model QueryAudit {
  id            String   @id @default(cuid())
  userType      String
  nlQuery       String?  @db.Text
  compiledQuery String?  @db.Text
  chartSpec     Json?
  filtersJson   Json?
  datasetsUsed  String[]
  rowsReturned  Int?
  latencyMs     Int?
  timestamp     DateTime @default(now())

  @@index([timestamp])
  @@index([userType])
  @@map("query_audits")
}
